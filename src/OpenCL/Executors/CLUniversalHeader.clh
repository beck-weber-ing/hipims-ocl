/*
 * ------------------------------------------
 *
 *	HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *	Luke S. Smith and Qiuhua Liang
 *	luke@smith.ac
 *
 *	School of Civil Engineering & Geosciences
 *	Newcastle University
 *
 * ------------------------------------------
 *	This code is licensed under GPLv3. See LICENCE
 *	for more information.
 * ------------------------------------------
 *	DEVICE MODULE (OPENCL, C99)
 * ------------------------------------------
 *	Universal header, included in every single
 *	program compiled by this model for OpenCL.
 * ------------------------------------------
 *
 */

// To be made configurable at a later date
#define USE_FUNCTION_STUBS			1
#define USE_ALTERNATE_CONSTRUCTS	1

// Enable to use printf with AMD devices
#ifdef DEBUG_OUTPUT
#pragma		OPENCL EXTENSION cl_amd_printf	 : enable
//#pragma		OPENCL EXTENSION cl_intel_printf : enable
#endif

#define		GRAVITY					9.81		// 9.80665
#define		GRAVITY_R				0.102		// 1.0 / 9.80665

// Type aliases to be consistent across different platforms
typedef char			cl_char;
typedef uchar		cl_uchar;
typedef short			 cl_short;
typedef ushort		cl_ushort;
typedef int			cl_int;
typedef int2		cl_int2;
//typedef int3		cl_int3;
typedef int4		cl_int4;
typedef int8		cl_int8;
typedef uint		cl_uint;
typedef uint2		cl_uint2;
//typedef uint3		cl_uint3;
typedef uint4		cl_uint4;
typedef uint8		cl_uint8;
typedef long		cl_long;
typedef long2		cl_long2;
//typedef long3		cl_long3;
typedef long4		cl_long4;
typedef long8		cl_long8;
typedef ulong		cl_ulong;
typedef ulong2		cl_ulong2;
//typedef ulong3		cl_ulong3;
typedef ulong4		cl_ulong4;
typedef ulong8		cl_ulong8;
//typedef half		cl_half;			// Requires OpenCL extension...
typedef float			 cl_float;
typedef float2			cl_float2;
//typedef float3			cl_float3;
typedef float4			cl_float4;
typedef float8			cl_float8;


// OpenCL Error Checking Macros

#define CL_ERR_TO_STR(err) case err: return #err

inline char const * clGetErrorString(cl_int const err) {
	switch(err)
		{
			CL_ERR_TO_STR(CL_SUCCESS);
			CL_ERR_TO_STR(CL_DEVICE_NOT_FOUND);
			CL_ERR_TO_STR(CL_DEVICE_NOT_AVAILABLE);
			CL_ERR_TO_STR(CL_COMPILER_NOT_AVAILABLE);
			CL_ERR_TO_STR(CL_MEM_OBJECT_ALLOCATION_FAILURE);
			CL_ERR_TO_STR(CL_OUT_OF_RESOURCES);
			CL_ERR_TO_STR(CL_OUT_OF_HOST_MEMORY);
			CL_ERR_TO_STR(CL_PROFILING_INFO_NOT_AVAILABLE);
			CL_ERR_TO_STR(CL_MEM_COPY_OVERLAP);
			CL_ERR_TO_STR(CL_IMAGE_FORMAT_MISMATCH);
			CL_ERR_TO_STR(CL_IMAGE_FORMAT_NOT_SUPPORTED);
			CL_ERR_TO_STR(CL_BUILD_PROGRAM_FAILURE);
			CL_ERR_TO_STR(CL_MAP_FAILURE);
			CL_ERR_TO_STR(CL_MISALIGNED_SUB_BUFFER_OFFSET);
			CL_ERR_TO_STR(CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST);
			CL_ERR_TO_STR(CL_COMPILE_PROGRAM_FAILURE);
			CL_ERR_TO_STR(CL_LINKER_NOT_AVAILABLE);
			CL_ERR_TO_STR(CL_LINK_PROGRAM_FAILURE);
			CL_ERR_TO_STR(CL_DEVICE_PARTITION_FAILED);
			CL_ERR_TO_STR(CL_KERNEL_ARG_INFO_NOT_AVAILABLE);
			CL_ERR_TO_STR(CL_INVALID_VALUE);
			CL_ERR_TO_STR(CL_INVALID_DEVICE_TYPE);
			CL_ERR_TO_STR(CL_INVALID_PLATFORM);
			CL_ERR_TO_STR(CL_INVALID_DEVICE);
			CL_ERR_TO_STR(CL_INVALID_CONTEXT);
			CL_ERR_TO_STR(CL_INVALID_QUEUE_PROPERTIES);
			CL_ERR_TO_STR(CL_INVALID_COMMAND_QUEUE);
			CL_ERR_TO_STR(CL_INVALID_HOST_PTR);
			CL_ERR_TO_STR(CL_INVALID_MEM_OBJECT);
			CL_ERR_TO_STR(CL_INVALID_IMAGE_FORMAT_DESCRIPTOR);
			CL_ERR_TO_STR(CL_INVALID_IMAGE_SIZE);
			CL_ERR_TO_STR(CL_INVALID_SAMPLER);
			CL_ERR_TO_STR(CL_INVALID_BINARY);
			CL_ERR_TO_STR(CL_INVALID_BUILD_OPTIONS);
			CL_ERR_TO_STR(CL_INVALID_PROGRAM);
			CL_ERR_TO_STR(CL_INVALID_PROGRAM_EXECUTABLE);
			CL_ERR_TO_STR(CL_INVALID_KERNEL_NAME);
			CL_ERR_TO_STR(CL_INVALID_KERNEL_DEFINITION);
			CL_ERR_TO_STR(CL_INVALID_KERNEL);
			CL_ERR_TO_STR(CL_INVALID_ARG_INDEX);
			CL_ERR_TO_STR(CL_INVALID_ARG_VALUE);
			CL_ERR_TO_STR(CL_INVALID_ARG_SIZE);
			CL_ERR_TO_STR(CL_INVALID_KERNEL_ARGS);
			CL_ERR_TO_STR(CL_INVALID_WORK_DIMENSION);
			CL_ERR_TO_STR(CL_INVALID_WORK_GROUP_SIZE);
			CL_ERR_TO_STR(CL_INVALID_WORK_ITEM_SIZE);
			CL_ERR_TO_STR(CL_INVALID_GLOBAL_OFFSET);
			CL_ERR_TO_STR(CL_INVALID_EVENT_WAIT_LIST);
			CL_ERR_TO_STR(CL_INVALID_EVENT);
			CL_ERR_TO_STR(CL_INVALID_OPERATION);
			CL_ERR_TO_STR(CL_INVALID_GL_OBJECT);
			CL_ERR_TO_STR(CL_INVALID_BUFFER_SIZE);
			CL_ERR_TO_STR(CL_INVALID_MIP_LEVEL);
			CL_ERR_TO_STR(CL_INVALID_GLOBAL_WORK_SIZE);
			CL_ERR_TO_STR(CL_INVALID_PROPERTY);
			CL_ERR_TO_STR(CL_INVALID_IMAGE_DESCRIPTOR);
			CL_ERR_TO_STR(CL_INVALID_COMPILER_OPTIONS);
			CL_ERR_TO_STR(CL_INVALID_LINKER_OPTIONS);
			CL_ERR_TO_STR(CL_INVALID_DEVICE_PARTITION_COUNT);
			CL_ERR_TO_STR(CL_INVALID_PIPE_SIZE);
			CL_ERR_TO_STR(CL_INVALID_DEVICE_QUEUE);

		default:
			return "UNKNOWN ERROR CODE";
		}
}

inline cl_int cl_assert(cl_int const code, char const * const file, int const line, bool const abort) {
	if (code != CL_SUCCESS) {
		char const * const err_str = clGetErrorString(code);
		fprintf(stderr,	"\"%s\", line %d: cl_assert (%d) = \"%s\"",file,line,code,err_str);

		if (abort) {
			// just crash on OpenCL errors.
			exit(code);
		}
	}
	return code;
}

#define cl(...)		cl_assert((cl##__VA_ARGS__), __FILE__, __LINE__, true);
#define cl_ok(err) cl_assert(err, __FILE__, __LINE__, true);
